{"meta":{"title":"Loong","subtitle":"Nothing is impossible to a willing heart !","description":"This is Loong's blog","author":"Loong","url":"https://xiao-long.club","root":"/"},"pages":[{"title":"","text":"404","path":"404/index.html","date":"12-11","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"12-11","excerpt":""},{"title":"关于我","text":"一名努力的前端菜鸟 欢迎加入前端学不动大家庭 邮箱：longlonghezi@gmail.com","path":"about/index.html","date":"06-12","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"06-12","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"06-12","excerpt":""},{"title":"message","text":"","path":"message/index.html","date":"12-13","excerpt":""}],"posts":[{"title":"VueX 相关问题汇总","text":"参考资料 Vue X 什么是 VueX ？VueX 是专门为 Vue.js 应用程序开发的状态管理工具。它采用 ==集中式存储管理应用== 所有组件的状态；更改状态的唯一方式是提交 ==mutation== ，例如： this.$store.commit(&#39;SET_VIDEO_PAUSE,video_pause,SET_VIDEO_PAUSE 为 ==mutation==属性中定义方法。 VueX 解决了什么问题 ？解决了两个问题： 多个组件依赖于统一状态时，对于多层嵌套的组件传值将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。 来自不同组件的行为需要变更同一状态。以往采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 什么时候用 VueX ？当项目遇到以下两种情况时： 多个组件依赖于同一状态时 来自不同组件的行为需要变更同一状态 VueX 的 5 个核心属性是什么 ？分别是：==state== / ==getter== / ==mutation== / ==action== / ==module== VueX 中状态储存在哪里，怎么改变它 ？储存在 ==state== 中 ， 改变VueX中的状态唯一途径就是 显示的提交（commit）mutaion VueX 中状态是对象，使用时候需要注意什么 ？因为对象是引用类型，浅拷贝后，依旧会影响原 state 中的状态改变 ， 这是不被允许的；所以要进行深拷贝后在修改。 如何在组件中批量使用 VueX 的 state 状态 ？使用 ==mapState== 辅助函数，利用对象展开运算符将 state 混入 computed 对象中 123456import &#123; mapState &#125; from 'vuex'export default &#123; computed : &#123; ...mapState ( [ 'price' , 'number' ] ) &#125;&#125; Vuex 中要从 state 派生一些状态出来 ， 且多个组件使用它 ， 该怎么做 ？使用 ==getter== 属性，相当于 Vue 中的计算属性 ==computed== ，只有原状态改变派生状态才会发生改变。 ==getter== 接收两个参数，第一个参数是 ==state== ，第二个参数是 ==getters==(可以用来访问其他 getter ) 12345678910111213141516const store = new Vuex.Store ( &#123; state : &#123; price : 10, number : 10, discount :0.7 &#125;, getters : &#123; total : state =&gt;&#123; return state.price * state.number &#125;, discountTotal : ( state , getters )=&gt;&#123; return state.discount * getters.total &#125; &#125; &#125; ) 然后在组件在中可以用计算属性 ==computed== 通过 this.$store.getters.total 这样来访问这些派生转态 12345678computed :&#123; total ()&#123; return this.$store.getters.total &#125;, discountTotal ()&#123; return this.$store.getters.discounTotal &#125;&#125; 怎么通过 getter 来实现在组件内可以通过特定条件来获取state的状态 ？通过让 ==getter== 返回一个函数 ， 来实现给 ==getter== 传参 。 然后通过参数来进行判断从而获取 ==state==中满足要求的状态。 12345678910111213const store = new Vuex.Store(&#123; state:&#123; todos :[ &#123; id : 1 , text : '....' , done :'true'&#125;, &#123; id : 2 , text : '....' , done :'false'&#125;, ] &#125;, getters:&#123; getTodoById:( state ) =&gt; ( id ) =&gt;&#123; return state.todos.find(todo=&gt;todo.id === id) &#125; &#125;&#125;) 然后在组件中可以使用计算属性 ==computed== 通过 this.$store.getters.getTodoById(2) 这样来访问这些派生转态。 12345678computed : &#123; getTodoById()&#123; return this.$store.getters.getTodoById &#125;&#125;,mounted()&#123; console.log(this.getTodoById(2).id) // false&#125; 如何在组件中批量使用 Vuex 的 getter 属性 ？使用 ==mapGetters== 辅助函数，利用对象展开运算符将 ==getter== 混入 ==computed== 对象中 123456789import &#123; mapGetters &#125; from 'vuex'export default &#123; computed :&#123; ...mapGetters( myTotal : 'total', myDiscountTotal : 'discountTotal' ) &#125;&#125; 在 Vuex 的 state 中有状态 number 表示货物数量，在组件中怎么改变它 ？首先在 ==mutations== 中注册一个 ==mutation==( 谬忒神思 ) 12345678910const store = new Vuex.Store(&#123; state :&#123; number :10 &#125;, mutations :&#123; SET_NUMBER( state , data )&#123; state.number = data &#125; &#125;&#125;) 在组件中使用 this.$store.commit 提取 ==mutation== ，改变 ==number== 的状态 1this.$store.commit( 'SET_NUMBER' , 20 ) 在 Vuex 中使用 mutation 要注意什么 ？==mutation 必须是同步函数== 在组件中一次提交多个 mutation ，怎么写使用更方便 ？使用 mapMutations 辅助函数 ，在组件中这么使用 12345methods :&#123; ...mapMutations(&#123; setNumber : \"SET_NUMBER\" &#125;)&#125; Vuex 中 action 和 mutation 有什么区别 ？ ==action== 提交的是 ==mutation== ，而不是直接变更状态 。 ==mutation== 可以直接变更状态。 ==action== 可以包含任意异步操作 ，==mutation==只能同步操作。 提交方式不同 ， ==action== 是用 this.$store.dispatch(&#39;ACTION_NAME,data&#39;) 来提交 。 ==mutation== 是用 this.$store.commit(&#39;SET_NUMBER&#39;,10) 来提交。 接收参数不同，==mutation== 第一个参数是 ==state== ，而 ==action== 第一个参数是 ==context== ，其包含了 12345678&#123; state , // 等同于 ' store.state ' , 若在弄快中则为局部状态 rootState , // 等同于 ' store.state ' , 只存在于模块中 commit , // 等同于 ' store.commit ' dispatch , // 等同于 ' store.dispatch ' getters , // 等同于 ' store.getters ' rootGetters // 等同于 ' store.gettres ' ,只存在于模块中&#125; Vuex 中 action 和 mutation 有什么相同点 ？第二个参数都可以接收外部提交时传来的参数。 this.$store.dispatch( &#39;ACTION_NAME&#39; , data ) this.$store.commit( &quot;SET_NUMBER&quot; , data) 在组件中多次提交同一个 action ，怎么写更方便 ？使用 ==mapAction== 辅助函数，在组件中这么使用 ： 123456import &#123; mapAction &#125; from 'vuex'methods :&#123; ...mapAction(&#123; setNumber : 'SET_NUMBER' &#125;)&#125; Vuex 中 action 通常是异步的 ， 那么如何知道 action 什么时候结束 ？在 ==action== 函数中返回 ==Promise== ，然后再提交的时候用 ==then== 处理 123456789101112action :&#123; SET_NUMBER_A( &#123; commit &#125; , data)&#123; return new Promise(( resolve , reject )=&gt;&#123; setTimeout(()=&gt;&#123; conmmit( 'SET_NUMBER' , 10) &#125;,2000) &#125;) &#125;&#125;this.$store.dispatch('SET_NUMBER_A').then(()=&gt;&#123; .......&#125;) Vuex 中有两个 action ，分别是 actionA 和 actionB ，其内部都是异步操作，在 actionB 要提交 actionA ，需要在 actionA 处理结束只有再处理其他操作 ， 怎么实现 ？利用 ES6 的 ==async== 和 ==await== 来实现。 12345678actions:&#123; async actionA(&#123; commit &#125;)&#123; ...... &#125; async actionB(&#123; commit &#125;)&#123; await dispatch ( 'actionA' ) // 等待 actionA 完成 &#125;&#125; 有用过 Vuex 模块吗 ？ 为什么要用 ？ 怎么使用 ？ 有 ， 因为使用单一状态树 ，应用的所有状态会集中到一个比较大的对象 。当应用变得非常复杂时 ，==store== 对象就可能变得非常臃肿 ，不利于维护 。所以将 ==store== 分割成模块（==module==）。每个模块拥有自己的 ==stare== 、==mutation== 、==action== 、==getters== ；甚至是嵌套子模块，从上至下进行同样方式分割 。 在 ==module== 文件新建 moduleA.js 和 moduleB.js 文件，在文件中写入 ↓ ↓ ↓ 12345678910111213141516171819const state = &#123; ....&#125;const getters = &#123; ....&#125;const mutations = &#123; ....&#125;const actions = &#123; ....&#125;export default &#123; state, getters, mutations, actions&#125; 然后在 index.js 中引入模块 1234567891011121314import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex)import moduleA from './module/moduleA'import moduleB from './module/moduleB'const store = new Vuex.Store(&#123; modules:&#123; moduleA, moduleB &#125;&#125;)export default store 在模块中 ，getter 和 mutation 接收的第一参数 state ，是全局的还是模块的 ？第一个参数 ==state== 是模块的 ==state== ，也就是局部的 ==state== 在模块中 ， getter 、mutation 、action 中如何访问全局的 state 和 getter ？ 在 ==getter== 中可以通过第三个参数 ==rootState== 访问到全局的 ==state== ，可以通过第四个参数 ==rootGetters== 访问到全局 ==getters== 。 在 ==mutation== 中不可以访问全局的 ==state== 和 ==getter== ，只能访问到局部的 ==state== 。 在 ==action== 中第一参数 ==context== 中的 context.rootState 访问到全局的 ==state== ，context.rootGetters 访问全局的 ==getter== 。 在组件中怎么访问 Vuex 模块中的 getter 和 state ，怎么提交 mutation 和 action ？ 直接通过 this.$store.getters 和 this.$store.state 来访问模块中的 ==getter== 和 ==state== 。 直接通过 this.$store.commit(&#39;mutationA&#39; , data) 提交模块中的 ==mutation== 。 直接通过 this.$store.dispatch(&#39;actionA&#39; , data) 提交模块中的 ==action== 。 用过 Vuex 模块的命名空间吗 ？ 为什么使用 ，怎么使用 ？默认情况下 ，模块内部的 ==action== 、==mutation== 和 ==getter== 是注册在全局命名空间 ，如果多个模块中 ==action== 、==mutation== 的命名都一样，那么提交 ==mutation== 、==action== 时 ，将会触发所有模块中命名相同的 ==mutation== 、==action== 。 这样有太多耦合， 如果要使你的模块具有更高的封装度和复用性，你可以通过添加 ==namespaced : true== 的方式使其成为带命名空间的模块 1234567export default &#123; namespaced: true, state, getters, mutations, actions&#125; 怎么在带命名空间的模块内提交全局的 mutation 和 action ？将 { root: true} 作为第三个参数传给 ==dispatch== 或 ==commit== 即可 12this.$store.dispatch('actionA', null, &#123; root: true &#125;)this.$store.commit('mutationA', null, &#123; root: true &#125;) 如何在带命名空间的模块内注册全局的 action ？12345678actions: &#123; actionA: &#123; root: true, handler ( context , data )&#123; ..... &#125; &#125;&#125; 组件中怎么提交 modules 中的 moduleA 和 mutationA ?1this.$store.commit('moduleA/mutationA', data) 怎么使用 mapStates / mapActions / mapMutations 这些函数来绑定带命名空间的模块 ？首先使用 ==createNamespacedHelpers== 创建基于某个命名空间辅助函数 123456789101112131415161718import &#123; createNamespacedHelpers &#125; from 'vuex'const &#123; mapState , mapActions &#125; = createNamespacedHelpers('moduleA')export default &#123; computed: &#123; // 在 module/moduleA 中查找 ...mapState(&#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;) &#125;, methods: &#123; // 在 module/moduleA 中查找 ...mapActions([ 'actionA', 'actionB' ]) &#125;&#125; Vuex 插件用过吗 ？ 怎么用简单介绍一下Vuex 插件就是一个函数， 它接收 ==store== 作为唯一参数。 在 Vuex.Store 构造器选项 plugins 引入。 在 state/plugin.js 中写入 12345export default function createPlugin(param)&#123; return store =&gt;&#123; .... &#125;&#125; 然后在 state/index.js 文件中写入 123456import createPlugin from './plugin.js'const plugin = createPlugin()const store = new Vuex.Store(&#123; // ... plugins: [myPlugin]&#125;) 在 Vuex 插件中怎么监听组件中提交 mutation 和action ？ 用 Vue.Store 的实例方法 subscribe 监听组件中提交 mutation 用 Vue.Store 的实例方法 subscribeAction 监听组件中提交 ==action== 在==store/plugin.js== 文件中写入 123456789101112131415161718192021export default function createPlugin(param) &#123; return store =&gt; &#123; store.subscribe((mutation, state) =&gt; &#123; console.log(mutation.type)//是那个mutation console.log(mutation.payload) console.log(state) &#125;) // store.subscribeAction((action, state) =&gt; &#123; // console.log(action.type)//是那个action // console.log(action.payload)//提交action的参数 // &#125;) store.subscribeAction(&#123; before: (action, state) =&gt; &#123;//提交action之前 console.log(`before action $&#123;action.type&#125;`) &#125;, after: (action, state) =&gt; &#123;//提交action之后 console.log(`after action $&#123;action.type&#125;`) &#125; &#125;) &#125;&#125; 然后在store/index.js文件中写入 123456import createPlugin from './plugin.js'const plugin = createPlugin()const store = new Vuex.Store(&#123; // ... plugins: [myPlugin]&#125;) 在v-model上怎么用Vuex中state的值 ？需要通过computed计算属性来转换。 123456789101112&lt;input v-model=\"message\"&gt;// ...computed: &#123; message: &#123; get () &#123; return this.$store.state.message &#125;, set (value) &#123; this.$store.commit('updateMessage', value) &#125; &#125;&#125;","path":"2019/11/23/Vue 基础-2/","date":"11-23","excerpt":"","tags":[{"name":"Vue","slug":"Vue","permalink":"https://xiao-long.club/tags/Vue/"}]},{"title":"防抖与节流","text":"[toc] 防抖与节流一、什么是防抖防抖函数原理 ： 在事件被触发n秒后在执行回调，如果在这n秒内又被触发，则重新计时。将防抖函数想象为拍照过程中，类似于手机摄像常用的防抖；使用户拍出来的照片没有虚影。 防抖函数 debounce 的功能就相当于帮你判定什么时候按下快门。 fn 相当于快门 threshhold ( 阈值 ) 就相当于人体感知稳定所经历的时间 只有稳定之后才会按下快门，执行 fn ; 也就是说一旦间隔 threshhold 有一次抖动都会重新判定稳定。 如果 threshhold 间隔时间内一直稳定不下来，第一次触发 threshhold 毫秒之后 fn 不会被执行，同理一直不稳定， fn永远不会被执行（假如死循环） 1234567891011121314151617181920212223242526272829// 抖动之后执行函数function debounce(fn,threshhold)&#123; if( !fn instanceof Function )&#123; throw new TypeError( 'Expected a function' ) &#125; let timer = null // 定时器 return function(...args)&#123; if(timer) clearTimeout( timer ); //取消之前的任务 timer = setTimeout(()=&gt;&#123; fn.apply( this, args ) // 执行 fn 函数 &#125;,threshhold) &#125;&#125;// 抖动之前先执行一次函数，再进行防止抖动function debounce(fn,threshhold)&#123; if( !fn instanceof Function)&#123; throw new Error('Expectend a function') &#125; let timer = null return function(...args)&#123; if( timer ) clearTimeout( timer ); let callNow = !timer timer = setTimeout(()=&gt;&#123; timer = null &#125;) if(callNow) fn.apply( this, args ) &#125;&#125; 代码解析： debounce就相当于判断什么时候按下快门；其中传入的参数 fn 相当于快门，threshhold 相当于人挺感知到平稳的时间。如果连续调用 debounce 间隔时间小于 threshhold ,那么定时器将被清除重置 cleatTimeout(timer);最终在时间间隔大于 threshhold 时执行 fn.apply( this, args ) 相当于手不抖时按下快门。 二、什么是节流节流可以理解为限流；当单行道交通拥堵的时候，会遇到两种情况，其一红绿灯限制车辆的通行；其二交警到现场根据实际情况调整通行；这就是节流。同理由于单行道只能通过一辆车；所以节流只执行第一次传入的函数，后面传进来的都不执行。 节流的两种方式： 第二次触发距离第一次时间超过threshhold，则第二次会立即执行 threshhold间隔内函数fn无论触发多少次，第一次触发到threshholdms后都是只执行一次 通过定时器实现( 固定时间放行 ) 1234567891011121314throttle(fn, threshhold)&#123; if(!fn instanceof Function) &#123; throw new TypeError('Expected a function') &#125; let timer = null return function()&#123; if(!timer)&#123; timer =setTimeout(()=&gt;&#123; timer = null fn.apply( this ) &#125;,threshhold) &#125; &#125;&#125; 通过实践间隔实现 1234567891011121314151617function throttle(fn, threshhold) &#123; if(!fn instanceof Function) &#123; throw new TypeError('Expected a function') &#125; let limited = false; // 节流阀标志位 let start = Date.now(); threshhold = threshhold || 500 return function (...args) &#123; let current = Date.now(); limited = limited &amp;&amp; current- start &lt; threshhold if(!limited) &#123; fn.apply(this,args); limited = true; start = Date.now(); &#125; &#125;&#125; 代码解析：通过 limited 确认当前是否限流；第一次默认是不限流，第二次执行时开始限流；当两次时间相减 current- start 超过 threshhold 时间间隔；才会重新执行 fn.apply(this,args); 三、防抖与节流的对比相同点： 其实本质上都是为了节省程序的性能（防止高频函数调用） 借助了闭包的特性来缓存变量（状态） 都可以使用setTimeout实现 区别： 使用防抖，可能n个threshhold时间间隔之后fn也没执行，但是使用节流触发的threshhold间隔内有且只执行一次 同样threshhold间隔内连续触发，防抖只执行一次，而节流会执行两次，只是在不同的threshhold周期内 侧重点不同，防抖侧重于稳定只能执行一次，而节流强调限周期内次数，即执行频率，不限制所有时间内的总次数 四、封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 这个是用来获取当前时间戳的function now() &#123; return +new Date()&#125;/** * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param &#123;function&#125; func 回调函数 * @param &#123;number&#125; wait 表示时间窗口的间隔 * @param &#123;boolean&#125; immediate 设置为ture时，是否立即调用函数 * @return &#123;function&#125; 返回客户调用函数 */function debounce (func, wait = 50, immediate = true) &#123; let timer, context, args // 延迟执行函数 const later = () =&gt; setTimeout(() =&gt; &#123; // 延迟函数执行完毕，清空缓存的定时器序号 timer = null // 延迟执行的情况下，函数会在延迟函数中执行 // 使用到之前缓存的参数和上下文 if (!immediate) &#123; func.apply(context, args) context = args = null &#125; &#125;, wait) // 这里返回的函数是每次实际调用的函数 return function(...params) &#123; // 如果没有创建延迟执行函数（later），就创建一个 if (!timer) &#123; timer = later() // 如果是立即执行，调用函数 // 否则缓存参数和调用上下文 if (immediate) &#123; func.apply(this, params) &#125; else &#123; context = this args = params &#125; // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个 // 这样做延迟函数会重新计时 &#125; else &#123; clearTimeout(timer) timer = later() &#125; &#125;&#125;","path":"2019/11/09/实用技巧-03/","date":"11-09","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiao-long.club/tags/JavaScript/"}]},{"title":"时间处理","text":"时间处理1234567891011121314151617181920&#x2F;* 原生JS时间格式化 *&#x2F;let timeFormat &#x3D; (str,format&#x3D;2) &#x3D;&gt; &#123; var date,y,m,d,hh,mm,ss; date &#x3D; new Date(str * 1000);&#x2F;&#x2F;时间戳为10位需*1000，时间戳为13位的话不需乘1000 y &#x3D; date.getFullYear().toString().padStart(2,&quot;0&quot;) ; m &#x3D; (date.getMonth()+1 &lt; 10 ? &#39;0&#39;+(date.getMonth()+1) : date.getMonth()+1).toString().padStart(2,&quot;0&quot;); d &#x3D; date.getDate().toString().padStart(2,&quot;0&quot;) ; hh &#x3D; date.getHours().toString().padStart(2,&quot;0&quot;) ; mm &#x3D; date.getMinutes().toString().padStart(2,&quot;0&quot;) ; ss &#x3D; date.getSeconds().toString().padStart(2,&quot;0&quot;); if(format&#x3D;&#x3D;&#x3D;1)&#123; return &#96;$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;&#96; &#125; if(format&#x3D;&#x3D;&#x3D;2)&#123; return &#96;$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;&#96; &#125; &#125; 123456789timeFormate(timeStamp) &#123; let year &#x3D; new Date(timeStamp).getFullYear() let month &#x3D; new Date(timeStamp).getMonth() + 1 &lt; 10 ? &quot;0&quot; +(neDate(timeStamp).getMonth() + 1) : new Date(timeStamp).getMonth() + 1 let date &#x3D; new Date(timeStamp).getDate() &lt; 10 ? &quot;0&quot; +neDate(timeStamp).getDate() : new Date(timeStamp).getDate() let hh &#x3D; new Date(timeStamp).getHours() &lt; 10 ? &quot;0&quot; +neDate(timeStamp).getHours() : new Date(timeStamp).getHours() let mm &#x3D; new Date(timeStamp).getMinutes() &lt; 10 ? &quot;0&quot; +neDate(timeStamp).getMinutes() : new Date(timeStamp).getMinutes() let ss &#x3D; new Date(timeStamp).getSeconds() &lt; 10 ? &#39;0&#39; +neDate(timeStamp).getSeconds() : new Date(timeStamp).getSeconds() this.nowTime &#x3D; year + &quot;年&quot; + month + &quot;月&quot; + date + &quot;日&quot; + &quot; &quot; + hh &quot;:&quot; + mm +&quot;:&quot; + ss&#125; 倒计时12345678910111213141516171819202122232425var period = 60 * 1000 * 60 * 2var startTime = new Date().getTime();var count = 0var end = new Date().getTime() + periodvar interval = 1000var currentInterval = intervalfunction loop() &#123; count++ var offset = new Date().getTime() - (startTime + count * interval); // 代码执行所消耗的时间 var diff = end - new Date().getTime() var h = Math.floor(diff / (60 * 1000 * 60)) var hdiff = diff % (60 * 1000 * 60) var m = Math.floor(hdiff / (60 * 1000)) var mdiff = hdiff % (60 * 1000) var s = mdiff / (1000) var sCeil = Math.ceil(s) var sFloor = Math.floor(s) currentInterval = interval - offset // 得到下一次循环所消耗的时间 console.log('时：'+h, '分：'+m, '毫秒：'+s, '秒向上取整：'+sCeil, '代码执行时间：'+offset, '下次循环间隔'+currentInterval) // 打印 时 分 秒 代码执行时间 下次循环间隔 setTimeout(loop, currentInterval)&#125;setTimeout(loop, currentInterval)","path":"2019/10/25/实用技巧-02/","date":"10-25","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiao-long.club/tags/JavaScript/"}]},{"title":"数组去重","text":"1、对象去重1234567891011121314const list = [ &#123; id: 1, a: 1 &#125;, &#123; id: 2, a: 2 &#125;, &#123; id: 3, a: 3 &#125;, &#123; id: 1, a: 4 &#125;,]const result = list.reduce((acc, cur) =&gt; &#123; const ids = acc.map(item =&gt; item.id) console.log(ids) return ids.includes(cur.id) ? acc : [...acc, cur]&#125;, [])console.log(result)// -&gt; [ &#123; id: 1, a: 1&#125;, &#123;id: 2, a: 2&#125;, &#123;id: 3, a: 3&#125; ] 2、Set方法去重12345const num = [2, 1, 4, 6, 1, 2, 6, 3, 7, 7, 1, 9, 0]const result = Array.from(new Set(num)).sort((a, b) =&gt; &#123; return a - b&#125;)console.log(result) // [0, 1, 2, 3, 4, 6, 7, 9] 3、 For循环嵌套12345678910const num = [2, 1, 4, 6, 1, 2, 6, 3, 7, 7, 1, 9, 0]for (let i = 0; i &lt; num.length; i++) &#123; for (let j = i+1; j &lt; num.length; j++) &#123; if (num[i] === num[j]) &#123; num.splice(j, 1) j-- &#125; &#125;&#125;console.log(num) // [2, 1, 4, 6, 3, 7, 9, 0]","path":"2019/10/19/实用技巧-01/","date":"10-19","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiao-long.club/tags/JavaScript/"}]},{"title":"Vue基础","text":"官网：http://vuejs.org/ 中文官网： https://cn.vuejs.org/ 国内cdn : https://cdn.baomitu.com/ https://www.bootcdn.cn/ 1.【初始化】123456789&lt;div id=\"app\"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el=\"#app\", data:&#123; msg:'Hello Word !', &#125; &#125;);&lt;/script&gt; 2. 【条件v-if= v-else-if= v-else= 】eg 1: 1&lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt; eg 2: 12&lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt; eg 3: 123456789101112&lt;div v-if=\"type === 'A'\"&gt; A&lt;/div&gt;&lt;div v-else-if=\"type === 'B'\"&gt; B&lt;/div&gt;&lt;div v-else-if=\"type === 'C'\"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 3. 【条件渲染 v-show= 】1234567891011&lt;div id=\"app\"&gt; &lt;h1 v-show=\"showvalue\"&gt;Hello!&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el:\"#app\", data:&#123; showvalue:false &#125; &#125;)&lt;/script&gt; v-if vs v-show [ v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。 如果需要==非常频繁==地切换，则使用 ==v-show 较好==； 如果在==运行时条件很少改变==，则使用==v-if 较好==。] 4. 【循环 v-for=】 eg 1 : 12345678910111213141516&lt;ul id=\"app\"&gt; &lt;li v-for=\"item in items\"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var example1 = new Vue(&#123; el: '#app', data: &#123; items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125; &#125;)&lt;/script&gt; eg 2: 有索引的for 123456789101112131415161718 &lt;ul id=\"app\"&gt; &lt;li v-for=\"(item, index) in array\"&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var example1 = new Vue(&#123; el: '#app', data: &#123; parentMessage: '绵阳市', array: [ &#123; message: '涪城区' &#125;, &#123; message: '游仙区' &#125;, &#123; message: '安州区' &#125; ] &#125; &#125;)&lt;/script&gt; eg 3: 一个对象的 v-for 123456789101112131415161718&lt;ul id=\"app\" class=\"demo\"&gt; &lt;li v-for=\"value in object\"&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; object: &#123; firstName: 'John', lastName: 'Doe', age: 30 &#125; &#125; &#125;)&lt;/script&gt; ==**永远 ： 避免 v-if 和 v-for 用在一起**== 5. 【表单输入 v-model 】 v-model 指令在表单 、 及 元素上创建双向数据绑定。 ==只作用于form表单== v-model 其实就是 v-bind 和 v-on 的语法糖 更多参考 123456&lt;input v-model=\"message\" placeholder=\"edit me\"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;input v-model=\"checkGoodsList\" :value=\"val.id\" type=\"checkbox\" name=\"produce[]\"&gt;&lt;input v-model=\"checkGoodsList\" :value=\"val.id\" type=\"checkbox\" name=\"produce[]\"&gt;&lt;!--checkGoodsList 是数组，存放val.id--&gt; 6. 【事件 v-bind: 简写： 】 Mustache 语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令 123456789101112131415161718192021222324252627282930&lt;!-- 绑定一个属性 --&gt; &lt;img v-bind:src=\"imageSrc\"&gt; &lt;!-- 缩写 --&gt; &lt;img :src=\"imageSrc\"&gt; &lt;!-- 内联字符串拼接 --&gt; &lt;img :src=\"'/path/to/images/' + fileName\"&gt; &lt;!-- class 绑定 --&gt; &lt;div :class=\"&#123; red: isRed &#125;\"&gt;&lt;/div&gt; &lt;div :class=\"[classA, classB]\"&gt;&lt;/div&gt; &lt;div :class=\"[classA, &#123; classB: isB, classC: isC &#125;]\"&gt; &lt;!-- style 绑定 --&gt; &lt;div :style=\"&#123; fontSize: size + 'px' &#125;\"&gt;&lt;/div&gt; &lt;div :style=\"[styleObjectA, styleObjectB]\"&gt;&lt;/div&gt; &lt;!-- 绑定一个有属性的对象 --&gt; &lt;div v-bind=\"&#123; id: someProp, 'other-attr': otherProp &#125;\"&gt;&lt;/div&gt; &lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt; &lt;div v-bind:text-content.prop=\"text\"&gt;&lt;/div&gt; &lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt; &lt;my-component :prop=\"someThing\"&gt;&lt;/my-component&gt; &lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt; &lt;child-component v-bind=\"$props\"&gt;&lt;/child-component&gt; &lt;!-- XLink --&gt; &lt;svg&gt;&lt;a :xlink:special=\"foo\"&gt;&lt;/a&gt;&lt;/svg&gt; v-bind的 指令详解参考这里 v-bind 和 v-model 的区别 参考这里 7. 【事件 v-on: 简写: @ 】1234567891011121314151617181920212223242526272829303132&lt;!-- 方法处理器 --&gt;&lt;button v-on:click=\"doThis\"&gt;&lt;/button&gt;&lt;!-- 内联语句 --&gt;&lt;button v-on:click=\"doThat('hello', $event)\"&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button @click=\"doThis\"&gt;&lt;/button&gt;&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop=\"doThis\"&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent=\"doThis\"&gt;&lt;/button&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!-- 串联修饰符 --&gt;&lt;button @click.stop.prevent=\"doThis\"&gt;&lt;/button&gt;&lt;!-- 键修饰符，键别名 --&gt;&lt;input @keyup.enter=\"onEnter\"&gt;&lt;!-- 键修饰符，键代码 --&gt;&lt;input @keyup.13=\"onEnter\"&gt;&lt;!-- 点击回调只会触发一次 --&gt;&lt;button v-on:click.once=\"doThis\"&gt;&lt;/button&gt;&lt;!-- 对象语法 (2.4.0+) --&gt;&lt;button v-on=\"&#123; mousedown: doThis, mouseup: doThat &#125;\"&gt;&lt;/button&gt; 8. 【过滤器 】 可使用位置: 双花括号插值、v-bind 过滤器可以串联 1234&lt;!-- 在双花括号中 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- 在 `v-bind` 中 --&gt;&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt; eg 1234567891011121314151617181920212223242526&lt;div id=\"app\"&gt; 字母大小写转换：&lt;br /&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;message | toupper &#125;&#125;&lt;/p&gt; &lt;br /&gt; &lt;br /&gt; &lt;p&gt;汇率计算:&lt;br /&gt; 人名币： &#123;&#123;rmb&#125;&#125; 兑 &#123;&#123;rmb | topercentage&#125;&#125;日元&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var myApp = new Vue(&#123; el: '#app', data: &#123; message: 'hello vue ! ', rmb: 6 &#125;, filters: &#123; toupper: function(value)&#123; return value.toUpperCase(); &#125;, topercentage: function(value)&#123; return Math.round((value*16.086)*100)/100; &#125;, &#125;, &#125;);&lt;/script&gt; 9. 【Computed 计算属性】12345678910111213141516171819202122232425262728&lt;div id=\"app\"&gt; aDouble的值：&lt;mark&gt;&#123;&#123;aDouble&#125;&#125;&lt;/mark&gt;&lt;br /&gt; aPlus的值：&lt;mark&gt;&#123;&#123;aPlus-2&#125;&#125;&lt;/mark&gt;&lt;br /&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el:\"#app\", data: &#123; a: 1 &#125;, computed: &#123; // 仅读取 aDouble: function () &#123; return this.a * 3 &#125;, // 读取和设置 aPlus: &#123; get: function () &#123; console.log(\"To get function---\") return this.a + 1 &#125;, set: function (v) &#123; console.log(\"To set function\") this.a = v - 1 &#125; &#125; &#125;&#125;)&lt;/script&gt; 参考资料 10. 【watch 观察者】 eg 1: 123456789101112var vm = new Vue(&#123; data: &#123; a: 1, &#125;, watch: &#123; a: function (val, oldVal) &#123; console.log('new: %s, old: %s', val, oldVal) &#125;, &#125;&#125;) 、、comouted 在数据未发生变化时，优先读取缓存vm.a = 2 // =&gt; new: 2, old: 1 eg 2: 123456789101112131415161718192021222324252627282930313233343536var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3, d: 4, e: &#123; f: &#123; g: 5 &#125; &#125; &#125;, watch: &#123; a: function (val, oldVal) &#123; console.log('new: %s, old: %s', val, oldVal) &#125;, // 方法名 b: 'someMethod', // 深度 watcher c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125;, // 该回调将会在侦听开始之后被立即调用 d: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, immediate: true &#125;, e: [ function handle1 (val, oldVal) &#123; /* ... */ &#125;, function handle2 (val, oldVal) &#123; /* ... */ &#125; ], // watch vm.e.f's value: &#123;g: 5&#125; 'e.f': function (val, oldVal) &#123; /* ... */ &#125; &#125;&#125;) 10.1 handler方法和immediate属性12immediate:true&#x2F;&#x2F;代表如果在 wacth 里声明了 该属性值后 之后，就会立即先去执行里面的handler方法 eg: 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div id&#x3D;&quot;root&quot;&gt; &lt;div&gt; &lt;p&gt;FullName: &#123;&#123;fullName&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;FirstName: &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot;&gt;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; new Vue(&#123; el: &#39;#root&#39;, data: &#123; firstName: &#39;Dawei&#39;, lastName: &#39;Lou&#39;, fullName: &#39;&#39; &#125;, watch: &#123; &#x2F;&#x2F; firstName(newName, oldName) &#123; &#x2F;&#x2F; this.fullName &#x3D; newName + &#39; &#39; + this.lastName; &#x2F;&#x2F; &#125; firstName:&#123; handler(newName, oldName) &#123; this.fullName &#x3D; newName + &#39; &#39; + this.lastName; &#125;, &#x2F;&#x2F; 代表在wacth里声明了firstName这个方法之后立即先去执行handler方法 immediate: true, &#125; &#125; &#125;); &lt;&#x2F;script&gt; 10.2 deep属性 属性 deep，默认值是 false，代表是否深度监听。 Vue 不能检测到对象属性的添加或删除。deep 的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler。 123456789101112131415161718192021222324&lt;body&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;p&gt;obj.a: &#123;&#123;obj.a&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;obj.a: &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;obj.a&quot;&gt;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; new Vue(&#123; el: &#39;#app&#39;, data: &#123; obj: &#123; a: 123 &#125; &#125;, watch: &#123; obj: &#123; handler(newName, oldName) &#123; console.log(&#39;obj.a changed&#39;); &#125;, immediate: true &#125; &#125; &#125;); &lt;&#x2F;script&gt; 10.3 取消侦听 watch 会随着组件的销毁而销毁。 eg 1 12345678910var unwatch &#x3D; vm.$watch( &#39;value&#39;, function () &#123; doSomething() if (unwatch) &#123; unwatch() &#x2F;&#x2F; 注销watch &#125; &#125;, &#123; immediate: true &#125;) eg 2 12345const unWatch &#x3D; app.$watch(&#39;text&#39;, (newVal, oldVal) &#x3D;&gt; &#123; console.log(&#96;$&#123;newVal&#125; : $&#123;oldVal&#125;&#96;);&#125;) unWatch(); &#x2F;&#x2F;注销watch 参考资料 11.1 Computed 和 watch 的区别 ==都可以观察页面的数据变化==但： Computed 在数据未发生变化时，优先读取缓存。motheds方法 和 watch 方法是的每次都去执行函数。 Computed 有 setter 和 getter方法 12345678910111213 computed:&#123; fullName:&#123; //这里用了es6书写方法 set()&#123; alert(\"set\"); &#125;, get()&#123; alert(\"get\"); return this.firstName + \" \" +this.lastName; &#125;, &#125;&#125; 建议： 通常computed属性，而不是命令是的watch回调。 在数据变化时需执行异步操作，这时watch是非常有用的。 12 【methods 方法混入】123456789101112131415161718&lt;div id=\"app\"&gt; &lt;mark&gt;&#123;&#123;a&#125;&#125;&lt;/mark&gt; &lt;button @click=\"plus()\" &gt;左边的数字加 1&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:\"#app\", data: &#123; a: 1 &#125;, methods: &#123; plus: function () &#123; this.a++ &#125; &#125; &#125;)&lt;/script&gt; 13 [生命周期 - created 钩子函数 ]12345678910111213new Vue(&#123; data: &#123; userlist: null //用户列表 &#125;, created: function () &#123; //在数据被调用之前请求接口拿到数据 this.$http.get('http://127.0.0.1/__/vue-cart/get.php').then(function(res)&#123; this.userlist= res.body; &#125;,function()&#123; console.log('请求失败处理'); &#125;); &#125;&#125;) 参考资料： 生命周期图 生命周期钩子： 14 过渡 / 动画更多 12345678910111213141516171819202122232425&lt;style&gt; //定义show的css动画属性 .fade-enter-active, .fade-leave-active &#123; transition: opacity 1s; &#125; .fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123; opacity: 0; &#125;&lt;/style&gt;&lt;div id=\"demo\"&gt; &lt;button v-on:click=\"show = !show\"&gt; Toggle &lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#demo', data: &#123; show: true &#125; &#125;)&lt;/script&gt; ==注意== [ v-on:click=”show = !show” ]这个写法 15 AJAXgithub : https://github.com/pagekit/vue-resource cdn: https://cdn.jsdelivr.net/npm/vue-resource@1.5.1 12345678910111213&lt;script src&#x3D;&quot;[url]&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;[url]&#x2F;js&#x2F;vue-resource.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;&#123; &#x2F;&#x2F; GET &#x2F;someUrl this.$http.get(&#39;&#x2F;someUrl&#39;).then(response &#x3D;&gt; &#123; &#x2F;&#x2F; get body data this.someData &#x3D; response.body; &#125;, response &#x3D;&gt; &#123; &#x2F;&#x2F; error callback &#125;);&#125;&lt;&#x2F;script&gt; ==vue2.0之后，就不再对vue-resource更新，而是推荐使用axios。==vue-axios.js 12345678910111213new Vue(&#123; el: &#39;#app&#39;, data () &#123; return &#123; info: null &#125; &#125;, mounted () &#123; axios .get(&#39;https:&#x2F;&#x2F;api.coindesk.com&#x2F;v1&#x2F;bpi&#x2F;currentprice.json&#39;) .then(response &#x3D;&gt; (this.info &#x3D; response)) &#125;&#125;) 16 其他12v-html 输出真正的 HTML&lt;p&gt;Using v-html directive: &lt;span v-html=\"rawHtml\"&gt;&lt;/span&gt;&lt;/p&gt;","path":"2019/10/05/Vue 基础-1/","date":"10-05","excerpt":"","tags":[{"name":"Vue","slug":"Vue","permalink":"https://xiao-long.club/tags/Vue/"}]},{"title":"JavaScript基础 - 作用域","text":"作用域 ：—— 作用域是指一个变量的作用范围—— 在 JavaScript 一共有两种作用域 全局作用域 函数作用域 一、 全局作用域 直接编写在 script 标签中的 JavaScript 代码，都是全局作用域 全局作用域在页面打开时创建，页面关闭时销毁 在全局作用域中有一个全局对象 Window ，并且可以直接使用 Window代表的浏览器的窗口，它由浏览器创建。 在全局作用域中 ： 创建的变量都会作为 Window 对象的属性保存 创建的函数都会作为 Window 对象的方法保存 全局作用域中的变量都是全局变量 ，在页面的任意部分都可以访问。 1.1、 变量声明提前console.log(&quot;a=&quot;+a) // undefined var a = 123 使用 var 关键字声明的变量，会在所有的代码执行前被声明 （但不赋值） 如果声明时不适用 var 关键字 ，则变量不会被提前 1.2、 函数声明提前function fun() { console.log(&quot;我是第一个函数&quot;) } var fun2 = function ( ){ // var 提升但不赋值 console.log(&quot;我是第二个函数&quot;) } 使用函数声明形式创建的函数 function 函数名（形参）{ 代码块 } 它会在所有代码执行之前被创建，所以可以在函数声明前被调用 使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用。 一、 函数作用域var a = 10 ; function fun（）{ var b = 20 ; console.log(&quot;a=&quot;+a) } fun() //10 console.log(&quot;b=&quot;+b) // 报错 调用函数时创建函数作用域 ， 函数执行完毕后，销毁函数作用域。 每调用一次函数就会创建一个新的函数作用域，它们之间相互独立 。 在函数作用域中可以访问到全局变量。 在全局作用域中无法访问到函数作用域的变量 var a = 10 ; function fun（）{ var a = &quot;我是函数里面的 a &quot; ; console.log(&quot;a=&quot;+a) //a=我是函数里面的 a } fun() //10 console.log(&quot;a=&quot;+a) // a=10 当在函数作用域中操作一个变量时，优先在自身作用域中寻找这个变量， 如果这个变量存在，直接使用 。 如果没有这个变量，会自动向上一级寻找该变量；直到找到全局作用域， 如果全局作用域中也没有这个变量，就会报错。 在函数中想要访问全局变量可以使用 Window 对象 var a = 10 ; function fun（）{ console.log(&quot;a=&quot;+a) //a = undefined var a = &quot;我是函数里面的 a &quot; ; } fun() // undefined 在函数作用域中也有声明提前的特性 使用 var 关键字声明的变量 ，会在函数中所有代码执行前被声明（但是没有赋值） 函数声明也会在函数中所有代码执行之前执行。 var c = 20 ; function fun(){ c = 10 ; } console.log( c ) // 10 函数中，不适用 var 声明的变量都会成为全局变量（隐式全局变量） var e = 20 ; function fun(e){ console.log( e ) } fun() // undefined 定义一个形参就相当于在函数内部声明了一个变量","path":"2019/10/04/JavaScript基础-6/","date":"10-04","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiao-long.club/tags/JavaScript/"}]},{"title":"JavaScript基础 - 数组","text":"数组（Array） 数组也是个对象 它和普通对象功能类型，也是用来存值的 不同的是：普通对象是使用字符串作为属性名；而数组是使用数字来作为索引操作元素。 索引（index）：—— 从 0 开始的整数就是索引 数组的存储性能比普通对象要好，在开发中经常使用数组来存储一些数据 1234567var arr = new Array() ;console.log(typeof arr) //objectarr[0] = 10;arr[1] = 20; //向数组中添加元素console.log(arr[0]) //10console.log(arr[3]) // undefined 向数组中添加元素 语法 ：数组[索引] = 值一、获取数组对象 使用 length 获取数组长度 对于非连续的数组，使用 length 获取到数组长度为最大值+1—— 尽量不要写非连续数组12345var arr = new Array() ;console.log(typeof arr) //objectarr[0] = 10;arr[1] = 20; //向数组中添加元素 console.log(arr.length) //2 如果修改 length 大于原长度，则多出来的部分会空出来 如果修改 length 小于原长度，则多出的元素会被删除 向数组最后添加元素12语法 ： arr[arr.length]=70 二、数组字面量语法： var arr = []; console.log(typeof arr) //object 使用字面量创建数组时，可以在创建时就指定数组中的元素 123var arr = [1,2,3,4,5,6] console.log(arr)//\"1,2,3,4,5,6\" console.log(arr[2]) //3 使用构造函数创建数组时，也可以同时添加元素；将要添加的元素作为构造函数的参数进行传递；元素之间使用 ， 隔开12var arr = new Array(1,2,3,4,5);console.log(arr) //\"1,2,3,4,5\" 当只为数组中传入一个数值时；—— 数组字面量返回的是一个元素 12var arr = [10]console.log(arr) // \"10\" —— 构造函数返回的是数组长度 123var arr = new Array(10);console.log(arr) // \",,,,,,,,,\"console.log(arr.length) //10 数组中的元素可以是任意类型的数据 也可以是对象和函数 二、数组的方法push( ) 方法 （在数组结尾处）向数组添加一个或多个新的元素；并且返回数组的新长度； 可以将要添加的元素作为方法的参数传递；这些元素将会自动添加到数组的末尾 该方法会将新的数组长度进行返回1234var arr = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];var receive = arr.push(\"Kiwi\"); // 向 arr 结尾添加一个新元素 console.log(arr) //\"Banana, Orange, Apple, Mango,Kiwi\" console.log(receive); //5 pop( ) 方法 从数组中删除最后一个元素： 返回值为被删除元素1234var arr = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"]; var receive = arr.pop(); // 从 arr 删除最后一个元素（\"Mango\"） console.log(arr) //\"Banana, Orange, Apple, \" console.log(receive) //\"Mango\" 返回被删除的元素 unshift( ) 方法 （在开头）向数组添加新元素，并“反向位移”旧元素： 插入元素以后，其他元素的索引会依次调整 返回值为新数组的长度。123456789101112131415161718192021222324var arr = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"]; var receive = arr.unshift(\"Lemon\"); // 向 arr 开头添加一个新元素 console.log(arr) //\"Orange,Apple,Mango \" console.log(receive) //\"Banana\" ``` ###### shift( ) 方法- 删除首个数组元素，并把所有其他元素“位移”到更低的索引 - 返回值为被删除元素```jsvar arr = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"]; var receive = arr.shift(); // 从 arr 删除最后一个元素（\"Mango\"） console.log(arr) //\"Orange,Apple,Mango \" console.log(receive) //\"Banana\" 返回被删除的元素``` ###### concat( ) 方法- 通过合并（连接）现有数组来创建一个新数组：- 该方法不会对原数组参数影响- 返回一个新的数组- 该方法不仅可以传数组，还可以传入当个元素```jsvar arr1 = [\"Cecilie\", \"Lone\"];var arr2 = [\"Emil\", \"Tobias\", \"Linus\"];var name = arr1.concat(arr2); // 连接 arr1 和 arr2 concat( ) 方法不会更改现有数组。它总是返回一个新数组。 concat( ) 方法可以使用任意数量的数组参数 slice( ) 方法 裁剪数组的某个片段切出新数组 从数组中提取指定元素 第一个参数，截取开始的位置索引（截取内容包括开始索引的元素） 第二个参数，截取结束的位置索引（截取内容不包括结束索引的元素） 索引可以传递一个负值 如果传递一个负值，则从后往前计算 碰到负数加 length 计算 返回一个新数组，原数组保持不变 从数组元素 （”Orange”）开始切出一段数组 123var arr = [\"Banana\", \"Orange\", \"Lemon\", \"Apple\", \"Mango\"];var newArr = arr.slice(1); console.log(newArr) //[ 'Orange', 'Lemon', 'Apple', 'Mango' ] slice() 可接受两个参数，比如 (1, 3) 从开始参数选取元素，直到结束参数（不包括）为止 如果结束参数被省略，比如第一个例子，则 slice() 会切出数组的剩余部分。1234//索引 1 开始 索引 3 结束var arr = [\"Banana\", \"Orange\", \"Lemon\", \"Apple\", \"Mango\"];var newArr = arr.slice(1, 3); console.log(newArr); //[ 'Orange', 'Lemon' ] 1234//索引 2 开始 var arr = [\"Banana\", \"Orange\", \"Lemon\", \"Apple\", \"Mango\"];var newArr = arr.slice(2); console.log(newArr); //[ 'Orange', 'Lemon' ，\"Apple\", \"Mango\"] splice( ) 方法 可用于删除数组中的指定元素或者替换某个索引上的元素 第一个参数（2）定义了应添加新元素的位置（拼接）。 第二个参数（0）定义应删除多少元素。 其余参数（“Lemon”，“Kiwi”）定义要添加的新元素 返回一个包含已删除项的数组 原数组也会受影响123456789101112var arr = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];arr.splice(2, 0, \"Lemon\", \"Kiwi\");``` - 使用 splice() 来删除元素 1. 第一个参数（0）定义开始的位置索引。2. 第二个参数（1）定义应该删除多个元素。3. 其余参数被省略。没有新元素将被添加 1. 如果想实现 push 操作 length + 1 ； 4. 并将被删除的值作为返回值```jsvar arr = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];arr.splice(0, 1); // 删除 fruits 中的第一个元素 sort( ) 方法 该方法对数字中的元素进行排序 该方法会直接在原数组上进行修改 默认按照 Unicode 编码进行排序（数字也会才去该编码进行排序） 123var arr=[f, e, d, c, b, a];arr.sort();console.log(arr) // [a, b, c, d, e, f] 当对数组中的数字进行排序时，需要自己指定规则 在sort（）中添加一个回调函数，指定排序规则 回调函数中需要指定两个形参 浏览器会分别使用数组中的元素作为实参去调用回调函数 使用哪个元素调用不确定，但肯定的是数组中 a 一定在 b 前面 浏览器会根据回调函数的返回值来决定元素的位置 返回一个大于 0 的值，则元素会交换位置 返回一个小于 0 的值，则元素位置不变 返回一个等于 0 的值，则说明两个元素相等，也不交换位置 如果需要升序排列（return a - b）； 如果需要降序排列（return b - a）； 123456789101112131415161718var arr=[6, 5, 4, 3, 2, 11];arr.sort(function(a,b)&#123;&lt;!-- if(a &gt; b)&#123; return 1 &#125;else if(a &lt; b)&#123; return -1 &#125;else&#123; return 0 &#125; --&gt; //升序排列 return a - b //降序排列 return b - a&#125;);console.log(arr) // [ 2, 3, 4, 5, 6, 11] join( ) 方法 该方法可以将数组转换为一个字符串 变换字符串中间的连接符 （中间的隔开东西） 返回一个新数组，原数组无变化 1234var arr = [\"Banana\", \"Orange\",\"Apple\", \"Mango\"];var receive = arr.join(\" * \"); console.log(arr) //Banana,Orange,Apple,Mangoconsole.log(receive); //Banana * Orange * Apple * Mango revenue( ) 方法 该方法用于翻转数组（后面的去前面，前面的去后面） 该方法会直接修改原数组123var arr=[1, 2, 3, 4, 5, 6];arr.reverse();console.log(arr) // [6, 5, 4, 3, 2, 1] 三、数组的遍历 遍历数组就是把数组中所有元素取出来 1234var arr = [\"Banana\", \"Orange\", \"Lemon\", \"Apple\", \"Mango\"];for(var i=0 ; i &lt; arr.length ; i++)&#123; console.log(arr[i]) //Banana Orange Lemon Apple Mango&#125; 一般都使用 for 循环遍历数组 forEach（）方法遍历数组 该方法只支持 IE8 以上的浏览器 forEach（）方法需要一个函数作为参数；像这杨由我们创建但不由我们调用的函数，称之为“回调函数” 数组中有几个元素函数就会被执行几次，每次执行浏览器会将遍历到的元素以实参的形式传递进来，需要定义形参来读取这些元素 浏览器会在回调函数中传递三个参数 第一个参数，当前正在遍历的元素（value） 第二个参数，当前正在遍历元素的索引（index） 第三个参数，当前正在遍历的数组（Array）12345var arr = [\"Banana\", \"Orange\", \"Lemon\", \"Apple\", \"Mango\"];arr.forEach(function()&#123; &#125;) 去掉数组中重复的元素 ： 12345678910111213141516var arr=[1,2,3,4,1,5,1,5,4,3,2,2,5,6,1,2,4];//遍历当前数组for (var i = 0; i &lt; arr.length; i++) &#123; //获取当前元素后的所有元素 for (var j = i+1; j &lt; arr.length; j++) &#123; //判断两个元素是否相等 if (arr[i] === arr[j]) &#123; //如果相等说明出现重复，删除后面获取到的 j 对应的元素 arr.splice(j,1); //当删除 j 索引上的元素以后，后面的元素会自动补位 //此时为了不让补位上来的元素被跳过，使用 j-- 的自减来还原该索引 j--; &#125; &#125;&#125;console.log(arr) // [1, 2, 3, 4, 5, 6]","path":"2019/10/03/JavaScript基础-5/","date":"10-03","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiao-long.club/tags/JavaScript/"}]},{"title":"Git 相关指令","text":"初始化 Git1git init 添加当前项目到暂缓区1git add . 初始化项目1git commit -m &#39;初始化项目&#39; 将项目从云端拷贝下来1git clone url 创建文件夹1D:\\&gt;mkdir hello_git 初始化Git1git init Git配置1234567git config --global user.email &quot;903111958@qq.com&quot; &#x2F;&#x2F; 配置邮箱git config --global user.name &quot;lxl&quot; &#x2F;&#x2F; 配置姓名--global 用户级全局配置--system 系统级全局配置--local 仓库级本地配置如果不加参数默认仓库级本地配置 提交内容123456git add 新增到暂缓区git push 添加到暂缓区git status 查看状态 git commit 提交暂缓区内容git commit -a -m &#39;123&#39; 将暂存区与非暂存区内的所有修改内容全部提交 配置vs code 称为Git的默认编辑器123456code -help &#x2F;&#x2F;vs code 帮助code --wait &#x2F;&#x2F;打开 vs codegit config -global core.editor &quot;code --wait&quot; &#x2F;&#x2F;配置vs code 为描述编辑器git commit -m &#39;hehe&#39; &#x2F;&#x2F;提交描述内容简短时，不用打开编辑器也可提交 查看修改信息12git loggit show 86779101a10aefb2a25b52240a78c0c9bf8b2b1b(commit编号) &#x2F;&#x2F;查看log详细信息 删除Git中的不需要的12git rm new_git&#x2F;index.js &#x2F;&#x2F;删除某一个文件git rm -r new_git&#x2F; &#x2F;&#x2F;删除某一个文件夹 上传到 github 仓库12345678echo &quot;# my_study&quot; &gt;&gt; README.md &#x2F;&#x2F;创建一个文件git init &#x2F;&#x2F;初始化 git git add README.md &#x2F;&#x2F;将git加入暂缓区git commit -m &quot;first commit&quot; &#x2F;&#x2F;提交当前暂缓区中的内容git remote add origin https:&#x2F;&#x2F;github.com&#x2F;Canyon-Pioneer&#x2F;my_study.git &#x2F;&#x2F;上传到 github 添加远程仓库git push -u origin master &#x2F;&#x2F;将本地仓库的最新状态上传到 远程仓库git push &#x2F;&#x2F;默认传入 remote 中配置的远程仓库git pull &#x2F;&#x2F; 将远程仓库中的更新过的文件加载到本地 撤回提交1234567891011只存在本地git commit --amend -m &quot;备注修改&quot; &#x2F;&#x2F; 只是修改备注，不需要整个撤回git reset HEAD~1 &#x2F;&#x2F; 删除仓库中的提交（将当前仓库状态重置到前一个位置）保存到工作空间git reset --heard HEAD^ &#x2F;&#x2F; 彻底删除（仓库、暂存区、工作空间统统都删除了）revert（多人合作时建议使用）回滚修改创建一个新的 commit ，吧指定的 commit 按照相反方向编辑来撤销，且不修改历史记录git revert HEAD^ &#x2F;&#x2F;回滚到上一个 commitpush上远程仓库 撤销修改123456789101112工作空间的撤销修改 git checkout XXXX.js(某个误删文件) &#x2F;&#x2F; 恢复某个误删除文件 git checkout + 目录名 &#x2F;&#x2F; 将整个目录恢复到修改之前的样子 git clean -i &#x2F;&#x2F; 删除工作区中不想要的新建文件 git clean -f &#x2F;&#x2F; 删除工作区中不想要的新建文件 暂存区修改 git reset HEAD new_git &#x2F;&#x2F; 吧暂存区中的 new_git 移到工作区 git reset new_git &#x2F;&#x2F; 吧暂存区中的 new_git 移到工作区 git reset &#x2F;&#x2F; 将暂存区中的所有文件 移到工作区 切换/创建分支12345git checkout HEAD~1 &#x2F;&#x2F; 切换到前一个分支 ~2 ~3 ~N ~可以前N个git checkout HEAD^ &#x2F;&#x2F; 切换到前一个分支git checkout XXXX &#x2F;&#x2F; 直接切换到摸一个分支git diff &#x2F;&#x2F; 对比&#x2F;查看修改内容git cat-file -p 15800d1（哈希值） &#x2F;&#x2F;查看哈希值对应对象的修改情况 查找是那个一次修改引起 BUG12345678910git bisect start git bisect bad &#x2F;&#x2F;给当前最新的 commit 标记为 badgit bisect good HEAD~9(某个正常的位置) 以下进行二分查找git bisect good &#x2F;&#x2F;表示该代码正常git bisect bab &#x2F;&#x2F;表示该代码异常当定位到 BUG 后结束查找、git bisect reset 查看文件修改次数1git blame README.md 小技巧 gitignore规则不生效123456789.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。解决方法就是先把本地缓存删除（改变成未track状态），然后再提交:git rm -r --cached .git add .git commit -m &#39;update .gitignore&#39; git忽略某个指定的文件(不从版本库中删除)123git update-index --assume-unchanged config.conf用git status查看一下，已经得到了自己想要的效果 git取消忽略某个指定的文件1git update-index --no-assume-unchanged config.conf 将当前版本回退到上一个版本，命令如下：1git reset --hard HEAD^ 回退到上两个版本1git reset – hard HEAD^^ 回退到指定版本123git log &#x2F;&#x2F;显示从最近到最远的提交日志git reset --hard commit_id &#x2F;&#x2F;回退到指定版本 查看命令历史1git reflog 拉取暂存区文件并将其替换成工作区文件1gitcheckout-- &lt;file&gt; 跟踪取消，即把文件从git中拿出来，不再进行版本跟踪，但保留工作区的文件。1git rm - - cached filename 查看工作区和版本库里面最新版本的区别123git diff HEAD – readme.txtgit diff命令比较的是工作目录中当前文件与暂存区快照之间的差异，也就是修改之后还没有暂存起来的变化内容 将工作去的内容放入版本库的暂存区1git add readme.txt 将暂存区的内容提交到当前分支1git commit -m &quot;git tracks changes&quot; 显示工作目录和暂存区的状态1git status 删除一个文件1git rm test.txt 从远程库克隆项目1git clone 项目地址 创建分支，然后切换到分支1234567git checkout -b devgit checkout命令加上-b参数表示创建并切换，相当于以下两条命令：git branch devgit checkout dev 查看当前分支123git branchgit branch命令会列出所有分支，当前分支前面会标一个*号 git merge命令用于合并指定分支到当前分支1git merge dev 删除本地分支1git branch -d dev 删除远程dev分支1git push origin :dev 切换分支1git checkout &lt;name&gt; 查看远程库的信息1git remote 或 git remote -v 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：12345git push origin master如果要推送其他分支，比如dev，就改成：git push origin dev 拉取分支1git pull","path":"2019/09/28/常用开发工具-2/","date":"09-28","excerpt":"","tags":[{"name":"Git","slug":"Git","permalink":"https://xiao-long.club/tags/Git/"}]},{"title":"JavaScript基础 - 对象","text":"JavaScript 中的数据类型 — string —- 字符串 — Number —- 数值 — Boolean —- 布尔值 — null —– 空值 — Undefined —- 未定义———— 以上五种数据类型属于基础数据类型，只要不是以上五种，全部都是对象。 Object 对象—— 对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。 一 、对象的分类 内建对象 ： 在ES标准定义的对象，在任何的ES的实现中都可以使用 比如 ： Math String Number Boolean Function 宿主对象 ： 由 JavaScript 的运行环境提供的对象，目前来讲主要指又浏览器提供的对象 比如 ： Bom DOM 自定义对象 ： 由开发人员自己创建的对象。 二 、对象的基本操作2.1 创建对象及调用 使用 new 关键字调用的函数，是构造函数 construction ； – 构造函数是专门用来创建对象的函数 使用 typeof 检查一个对象时 ，返回 object 。 在对象中保存的值称之为属性 var obj = new Object( ); // 给 obj 添加属性 obj.name =&quot;孙悟空&quot;； obj.age =&quot;18&quot; //读取对象中的属性 console.log (obj.age) // 18 //修改对象中的属性 obj.age = &quot;20&quot; console.log (obj.age) // 20 //删除对象属性 delete obj.age console.log (obj.age) // undefined 2.1.1 向对象中添加属性 —— 语法如下 ：语法 ： 对象 . 属性名 = 属性值属性名 ： 对象的属性名不强制要求遵循标识符的规范（但使用时尽量按照标识符的规范去做） 如果要使用特殊的属性名，不能采用 . 的方式来操作。 需要使用另一种方式 ： 语法 ：[ “ 属性名 ” ] = 属性值 读取时也要采取这种方式 使用 [ ] 这种方式操作属性，更加灵活。 在 [ ] 中可以直接传递一个变量，这样变量是多少，就会读取到多少。 2.1.2 读取对象中的属性 —— 语法如下 ：语法 ： 对象 . 属性名 如果读取对象中没有的属性，不会报错而是返回 undefined 2.1.3 修改对象中的属性值 —— 语法如下：语法 ： 对象 . 属性名 = 新值属性值 ： JavaScript 对象的属性值，可以是任意的数据类型 甚至可以是一个对象（ object ） 2.1.4 删除对象的属性 —— 语法如下 ：语法 ： delete 对象 . 属性名2.2 in 运算符通过该运算符可以检查一个对象中是否含有指定的属性—— 如果有值则返回 true ，没有则返回 false 语法 ：“ 属性名 ” in 对象 三 、基础数据类型和引用数据类型基本数据类型 — string —- 字符串 — Number —- 数值 — Boolean —- 布尔值 — null —– 空值 — Undefined —- 未定义 引用数据类型 — Object —- 对象 JavaScript 的变量都是保存在栈内存中。 基础数据类型直接在 栈内存 中存储 。 值与值之间相互独立 ，修改一个变量，不会影响另外一个值 对象是保存在 堆内存 中，每创建一个新的对象，就会在堆内存中开辟出一个新空间 而变量保存的是对象的内存地址（对象的引用）。如果两个对象保存的是同一个对象的引用，当其中一个通过变量修改值以后，另外一个也会受到影响其中一个赋值为 null 后 ，将断开与对象的 引用地址 断开链接关系 当比较两个基础数据类型的值时，就是单纯的 值 之间的比较 当比较两个引用数据类型（ Object ）时，它比较的是对象的 内存地址 如果两个对象时一模一样的，但地址不同，它也会返回 false 四 、对象字面量 使用对象字面量创建对象 语法 ： var obj = { } 使用对象字面量，可以在创建时直接指定对象的属性 对象字面量的属性名可以加引号，也可以不加；建议不加 如果使用一些特殊的名字，则必须加引号语法 ：var object = {name : “猪八戒”， age : &quot;29&quot;, sex :&quot;男&quot; }； 属性名和属性值时一组成对的结构 名和值之间使用 ： 链接 多个值之间使用 ， 隔开 如果一个属性之后没有其他属性了，就不用接 ， 五 、对象的方法 对象的属性可以是任何数据类型，也可以是函数 函数也可以称为对象的属性 如果一个函数作为对象的属性保存 那么此时函数就是这个对象的方法 调用这个函数就是调用这个对象的方法 （method） 方法与函数只是名称上面的区别，没有本质上的区别。 var obj = { name : &quot;孙悟空&quot;， age ： “600”， sayName ： function（）{ console.log(obj.name) } } //调用方法 obj.sayName()； 枚举对象中的属性使用 for ... in 语句 /* * 语法 ： * for （var 变量 in 对象）{ * * } */ for(var n in obj){ console.log(n) // obj 中的属性名称 console.log( obj[n] ) //取出 obj 中对应属性名的值 } for … in 语句，对象中有几个属性，循环体就执行几次 每次执行时会将属性名赋值给变量 九 、垃圾回收 程序运行过程中会产生垃圾；这些垃圾积攒过多了以后，会导致程序运行速度过慢。所以必须要有一个垃圾回收的机制，来处理程序运行过程中产生的垃圾。123var obj = new Object();obj = null //这时就产生了无法操作的对象，并且存在在内存中，无法使用 当一个对象没有任何的变量或者属性对它进行引用时，此时将永远无法操作该对象—— 此时这种对象就是个垃圾，这种对象多了以后就会占用大量内存；从而导致程序运行变慢。—— 所以这种垃圾必须进行清理。 在 JavaScript 中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁！—— 我们不需要也不能进行垃圾回收的操作 我们需要做的只是将不再使用的对象设置为 null 。","path":"2019/09/28/JavaScript基础-4/","date":"09-28","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiao-long.club/tags/JavaScript/"}]},{"title":"常用工具配置 eslintrc.js","text":"webStorm 配置 点击 File → Settings → Languages &amp; Frameworks → JavaScript → Code Quality Tools → ESLint 点击 File → Settings → Keymap → 搜索 fix → 选中JavaScript and TypeScript → Fix ESLint Problems → 右键 KeyBoard Shortcut 设置按键 点击 File → Settings → Editor → Code Style → JavaScript （设置缩进） VScode配置ESlint自动修复格式化 使用vscode安装 eslint + vuter + prettier 自动格式化代码配置： 文件 → 首选项 → 设置 → 用户设置 → 拓展 → ESlint → 点击 “在setting.json”中编辑 黏贴如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; &quot;workbench.editor.enablePreview&quot;: false, &#x2F;&#x2F;打开文件不覆盖 &quot;search.followSymlinks&quot;: false, &#x2F;&#x2F;关闭rg.exe进程 &quot;editor.minimap.enabled&quot;: false, &#x2F;&#x2F;关闭快速预览 &quot;liveServer.settings.donotShowInfoMsg&quot;: true, &#x2F;&#x2F;关闭liveserver提示 &quot;files.autoSave&quot;: &quot;afterDelay&quot;, &#x2F;&#x2F;打开自动保存 &quot;editor.fontSize&quot;: 16, &#x2F;&#x2F;设置文字大小 &quot;editor.lineHeight&quot;: 24, &#x2F;&#x2F;设置文字行高 &quot;editor.lineNumbers&quot;: &quot;on&quot;, &#x2F;&#x2F;开启行数提示 &quot;editor.quickSuggestions&quot;: &#123; &#x2F;&#x2F;开启自动显示建议 &quot;other&quot;: true, &quot;comments&quot;: true, &quot;strings&quot;: true &#125;, &quot;workbench.colorTheme&quot;: &quot;Darcula Theme from IntelliJ&quot;, &#x2F;&#x2F;指定工作台中使用的颜色主题 &quot;window.zoomLevel&quot;: 0, &#x2F;&#x2F; 调整窗口的缩放级别 &quot;editor.tabSize&quot;: 2, &#x2F;&#x2F;制表符符号eslint &quot;editor.formatOnSave&quot;: true, &#x2F;&#x2F;每次保存自动格式化 &quot;eslint.autoFixOnSave&quot;: true, &#x2F;&#x2F; 每次保存的时候将代码按eslint格式进行修复 &quot;prettier.eslintIntegration&quot;: true, &#x2F;&#x2F;让prettier使用eslint的代码格式进行校验 &quot;prettier.semi&quot;: false, &#x2F;&#x2F;去掉代码结尾的分号 &quot;prettier.singleQuote&quot;: true, &#x2F;&#x2F;使用带引号替代双引号 &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true, &#x2F;&#x2F;让函数(名)和后面的括号之间加个空格 &quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;, &#x2F;&#x2F;格式化.vue中html &quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;, &#x2F;&#x2F;让vue中的js按编辑器自带的ts格式进行格式化 &quot;vetur.format.defaultFormatterOptions&quot;: &#123; &quot;js-beautify-html&quot;: &#123; &quot;wrap_attributes&quot;: &quot;force-aligned&quot; &#x2F;&#x2F;属性强制折行对齐 &#125; &#125;, &quot;eslint.validate&quot;: [ &#x2F;&#x2F;开启对.vue文件中错误的检查 &quot;javascript&quot;, &quot;javascriptreact&quot;, &#123; &quot;language&quot;: &quot;html&quot;, &quot;autoFix&quot;: true &#125;, &#123; &quot;language&quot;: &quot;vue&quot;, &quot;autoFix&quot;: true &#125; ], &#125; .eslintrc 文件示例和解释","path":"2019/09/26/常用开发工具-1/","date":"09-26","excerpt":"","tags":[{"name":"WebStorm","slug":"WebStorm","permalink":"https://xiao-long.club/tags/WebStorm/"},{"name":"VsCode","slug":"VsCode","permalink":"https://xiao-long.club/tags/VsCode/"}]},{"title":"JavaScript基础 - 流程控制语句","text":"程序是由一条一条语句构成 语句是按照 自上向下、自左往右 的顺序一条一条执行 在 JavaScript 中可以使用 { } 来为语句进行分组 同一个 { } 中的语句称为 一组语句；要么一起执行，要么都不执行 一个 { } 中的语句称为 代码块 代码块后面就不用写 ； ，为了提高可读性建议写上。 JavaScript 的代码块 ，只具有分组的作用，没有其他作用；代码块内部的内容在外部完全可见。 通过流程控制语句可以控制程序执行流程 使程序可以根据一定的条件来选择执行 语句的分类 条件判断语句 条件分支语句 循环语句 一 、 条件判断语句使用条件判断语句可以在执行某个语句前进行判断如果该条件执行语句，条件不成立则不执行。 JavaScript 判断语句 —— if 语句语法 一 ：if（条件表达式）{ 代码块 } if 语句在执行时，会先对表达式进行判断， 如果表达条件为 true ，则 if 后的代码块执行； 如果表达条件为 false ，则 if 后的代码块不执行； if 语句只能控制紧随其后的语句 如果希望 if 语句可以控制多条语句，可以将这些语句放在 { } 中组成代码块。语法 二 ：if（条件表达式）{ 代码块 }else { 代码块 } if .... else ....语句 当该语句执行时，先对 if 后的条件表达式进行判断； 如果值为 true 执行 if 后的语句； 如果值为 false 执行 else 后的语句。语法 三 ：if（条件表达式）{ 代码块 1 }else if（）{ 代码块 2 }else if（）{ 代码块 3 }else { 代码块 4 } if ... else if ... else 当语句执行时，会从上到下依次对表达式进行求值判断 如果值为 true 则执行当前语句； 如果值为 false 则继续往下判断； 如果所有的条件都不满足，则执行最后的 else 。 该语句中只会有一个代码块被执行，一旦满足一个剩下的代码都不执行。 JavaScript 条件分支语句 —— switch 语句语法 一 ：switch （条件表达式）{ case 表达式 ： 代码块 ； break； case 表达式 ： 代码块 ； break； default ： 代码块 ； break； } 执行流程 在执行时会依次将 case 后表达式的值和 switch 后的条件值 进行全等比较。 如果比较结果为 true ，则从当前 case 开始执行代码块 当前这个 case 后面的所有代码都将执行；必须在代码最后添加一个 break 跳出执行代码块，不继续执行当前 case 之后的代码。 如果比较结果为 false ，则继续比较 如果所有比较都为 false ，则执行 default 之后的代码块 switch 语句和 if 语句在功能实际有重复 ，使用 switch 可以实现 if 的工程 同样 if 也可以实现 switch 的功能。 如果判断 “ 范围 ” 使用___________[ if ] 如果判断 “ 具体的值 ” 使用___________[ switch ] 二 、 循环语句循环语句通过循环语句可以反复执行一段代码多次 条件表达式写死 true 的循环，叫做 死循环 该循环不会停止，除非浏览器关闭，死循环在开发中慎用！！！！ 可以使用 break ，来终止循环。 创建循环的步骤 ： 创建一个初始化的变量 在循环中设置一个条件表达式 定义一个更新表达式，每次更新初始化变量 JavaScript 循环语句 —— while 语句语法 一 ：while（条件表达式）{ 代码块 ； } - while 语句执行时 ： 先对条件表达式进行求值判断 ； 如果值为 true ，则执行循环体； 循环体执行结束后，继续对表达式进行判断 如果值为 true ，则继续执行；依此类推。 直到对 条件表达式 求值 为 false 停止循环。JavaScript 循环语句 —— do … while 语句语法 一 ：do { 代码块 ； }while（条件表达式） - while 语句执行时 ： do ... while 语句在执行时，会先执行循环体， 循环体执行完毕后，在对 while 后的条件表达式进行判断， 如果为 true 则继续执行循环体，执行完毕后继续判断以此类推； 如果结果为 false ，则终止循环。 实际上 do ... while 和 while 功能类似，不同的是 while 是先判断后执行， 而 do ... while 是先执行后判断 do ... while 可以保证循环体只是执行一次， 而 while 不能。 JavaScript 循环语句 —— for 语句在 for 循环中，为我们提供给了专门的位置来放三个表达式；&nbsp;&nbsp;&nbsp; 1、初始化表达式&nbsp;&nbsp;&nbsp; 2、条件表达式&nbsp;&nbsp;&nbsp; 3、更新表达式 语法 一 ：for（初始化表达式；条件表达式；更新表达式）{ 代码块 } for循环执行流程： 1、 执行初始化表达式，初始化变量 （初始化表达式只会执行一次） 2、 执行条件表达式，判断是否执行循环 如果为true ，则执行更新表达式 如果为 false ，终止循环 3、 执行更新表达式，更新表达式执行完毕继续执行 条件表达式 for 循环三个部分都可以省略，也可以写在外面 如果 for 循环中不谢任何表达式，只写两个分好； 此时循环是一个死循环会一直执行下去，慎用 ！！！！！ for（ ；；）{ alert（“hello Word”） }1、嵌套的 for 循环****** ****** ****** ****** ****** 通过 for 循环来输出图像这个 for 循环执行几次，图形的高度就是多少它可以用来控制图形的高度 for(var i=0;i&lt;5;i++){ /* 在循环内部在创建一个循环，用来控制图形的宽度 外部 for 循环执行一次，内部 for 执行 5 次 内层循环决定图形宽度，执行几次图形的宽度就是多少 */ for（var j=0 ; j&lt;5 ;j++){ document.write(&quot; * &quot;); } document.write(&quot; &lt;br /&gt; &quot;); }输出如下图形 1 ： * ** *** **** ***** for（var i=0;i&lt;5;i++){ for(var j=0 ; j&lt;i+1;j++){ document.write( &quot;*&quot;) } document.write(&quot;&lt;br /&gt;&quot;) }输出如下图形 2 ： ***** **** *** ** * for（var i=0;i&lt;5;i++){ for(var j=0 ; j &lt; 5 - i ; j++){ document.write( &quot;*&quot;) } document.write(&quot;&lt;br /&gt;&quot;) }打印九九乘法表： for (var i = 1; i &lt; 10; i++) { for (var j = 1; j &lt;= i; j++) { document.write(j + &quot;*&quot; + i + &quot;=&quot; + i * j + &quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;) } document.write(&quot;&lt;br /&gt;&quot;) }2、break 和 continuebreak—关键字 break 可以用来退出 switch 或者 循环语句 break 和 continue 不能用于 if 判断 break 会立即终止离他最近的循环语句 //可以为循环语句创建一个 label 用来标识当前循环语句 label： for(var i=0 ;i&lt;5;i++){ for(var j=0;j&lt;10;j++){ break label; //结束外层循环 } }continue—关键字 continue 跳出当次循环（只跳过一次） continue 默认只会对离他最近的循环起作用 //可以为循环语句创建一个 label 用来标识当前循环语句 for( var i=0 ;i&lt;10 ;i++){ if( i===3){ continue } }3、测试程序的性能 程序执行前 — 开启计时器 &nbsp;&nbsp;&nbsp;&nbsp; //console.time（）&nbsp;&nbsp;&nbsp;&nbsp; 它需要一个字符串作为参数，这个字符串将会作为计数器的标识 测试程序执行完后执行 — 终止计数器 &nbsp;&nbsp;&nbsp;&nbsp; //console.timeEnd（） &nbsp;&nbsp;&nbsp;&nbsp; 它需要一个字符串作为参数，这个字符串将会作为计数器的标识","path":"2019/09/15/JavaScript基础-3/","date":"09-15","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiao-long.club/tags/JavaScript/"}]},{"title":"JavaScript基础 - 运算符","text":"运算符也叫操作符 通过运算符可以对一个或者多个值进行运算，并获得运算结果 比如 ： typeof 就是运算符，可以获得一个值的类型 它会将值的类型以字符串的形式进行返回 number string Boolean undefined object 一、 算数 - 运算符 当对非 Number 类型的值进行运算时，会将这些值转换为 Number 然后在进行运算（除了字符串的相加） 任何值和 NaN 做运算都是 NaN [ + ] 加法 —— 运算符 可以对两个值进行加法运算 ， 并将结果返回 如果两个字符串进行加法运算，则会做字符串拼接 将两个字符串拼接为一个字符串，并返回。 任何值和字符串做加法运算，都会先转化为字符串，然后再和字符串做拼串的操作 可以将任意的数据类型 + 一个 “ ” 即可将其转换为String 这是一种隐式的转换，由浏览器自动完成，实际上它也是调用了 String（） [ — ] 减法 —— 运算符 可以对两个值进行减法运算 ， 并将结果返回 [ * ] 乘法 —— 运算符 可以对两个值进行乘法运算 ， 并将结果返回 [ / ] 除法 —— 运算符可以对两个值进行乘法运算 ， 并将结果返回 任何值做 - * / 运算都会自动转化为 Number 我们可以用这一特点做隐式的类型转换 可以通过为一个值 -0 *1 /1来将其转换为 Number 原理和 Number（）函数一样 ，使用起来简单 [ % ] 去余 —— 运算符 可以进行取 余数 运算 ， 并将结果返回 二、 一元 - 运算符一元运算符，只需要一个操作符 -对于非 Number 类型的值 -它会先将其转换为 Number 再进行运算 （可以利用这一点对其他类型数据使用 + 将其转换为 Number 类型） [ + ] 正号 正号不会对数字产生任何影响 [ - ] 负号 负号可以对数字的符号进行取反 三、 自增和自减 - 运算符2.1 、 自增 通过自增可以使变量在自身的基础上加 1 对于一个变量自增以后，原变量的值也会立即自增 1 自增分为两种： 1234567 无论是 a + + 还是 + + a ，都会立即使原变量的值自增 1 不同的是 a + + 和 + + a 的值不同1. 后++ (a++) * a++的值等于原变量的值 （自增前的值）2. 前++ (++a) * ++a 的值等于原变量自增后的新值 2.2 、 自减 通过自增可以使变量在自身的基础上减少 1 自增分为两种： 1234567 无论是 a - - 还是 - - a ，都会立即使原变量的值自减少 1 不同的是 a - - 和 - - a 的值不同1. 后-- (a--) * a--的值等于原变量的值 （自增前的值）2. 前-- (--a) * --a 的值等于原变量自增后的新值 四、 逻辑 - 运算符JavaScript 提供三种逻辑运算符 1、 [ ! ] 非 [ ! ] 可以用来对一个值进行 非 运算 所谓非运算就是对一个布尔值进行取反操作 true 变 false ；false 变 true 如果对一个值进行两次取反， 它不会有变化 如果对非布尔元素进行取反，则会先将其转换为布尔值，然后在取反 所以我们可以利用该特点将其他数据类型转换为布尔值 可以为任意值取反两次，来将其转换为布尔值， 原理与Boolean（）函数一样 2、 [ &amp;&amp; ] 与 [ &amp;&amp; ] 可以对符号两侧的值进行 与 运算并返回结果 运算规则 两个值中只要有一个值为 false 就返回 false 只有两个值都为 true 才会返回 true JavaScript 中的 “ 或 ” 属于短路的 或 如果第一个直为 false ，则不会处理第二个值 [ &amp;&amp; ] 与 运算：一假全假 对于非布尔值进行 与 运算时 会先将其转换成布尔值，然后在进行运算；并且返回原值 如果第一个直为 true ，则必然返回第二个值；（返回原值） 如果两个值中有 false 则会直接返回第一个值；（返回原值） 1、 [ || ] 或 [ || ] 可以对符号两侧的值进行 与 运算并返回结果 运算规则 两个值中只要有一个值为 true 就返回 true 只有两个值都为 false 才会返回 false JavaScript 中的 “ 与 ” 属于短路的 与 如果第一个直为 true ，则不会处理第二个值 [ || ] 与 运算：一真全真 对于非布尔值进行 或 运算时 会先将其转换成布尔值，然后在进行运算；并且返回原值 如果第一个直为 true ，则会直接返回第一个值；（返回原值） 如果第一个值中有 false 则会直接返回第二个值；（返回原值） 五、 赋值 - 运算符1、 [ = ] 等于 可以将符号右侧的值 赋值 给符号左侧的变量 2、 [ += ] 加等于 a += 5 等价于 a = a + 5 3、 [ -= ] 加等于 a -= 5 等价于 a = a - 5 4、 [*= ] 加等于 a *= 5 等价于 a = a * 5 5、 [ /= ] 加等于 a /= 5 等价于 a = a / 5 6、 [ %= ] 加等于 a %= 5 等价于 a = a % 5 六、 关系 - 运算符 通过关系运算符可以比较两个值之间的大小关系 如果关系成立会返回 true ，不成立返回 false 1、 [ &gt; ] 大于号 判断符号左侧的值是否大于右侧 如果关系成立，返回 true ，不成立返回 false 2、 [ &gt;= ] 大于等于号 判断符号左侧的值是否 大于 或者 等于 右侧 如果关系成立，返回 true ，不成立返回 false 3、 [ &lt; ] 小于号 判断符号左侧的值是否小于右侧 如果关系成立，返回 true ，不成立返回 false 4、 [ &lt;= ] 大于等于号 判断符号左侧的值是否 小于 或者 等于 右侧 如果关系成立，返回 true ，不成立返回 false 5、 非数值类型的情况 对于非数字类型比较前 ， 先将其转化为 Number 类型 如果比较符两侧都是字符串，不会将其转换为 Number ，而是分别比较字符编码 比较字符编码时，一位一位进行比较 如果两位一样，则比较下一位 可以借用它来对英文进行排序 比较中文没有意义 比较两个字符串类型的数字 ， 可能会得到不可预期的结果 注意！！！在比较字符串类型的数字时，一定！ 一定！ 一定！ 要转型 任何值和NaN做任何比较都是false 七、 相等 - 运算符 相等运算符用来比较两个值是否相等， 如果相等返回 true ，不相等返回 false 1、 [ == ] 相等 使用 [ == ] 来做相等运算时 如果值的类型不相同 ，则会自动进行隐式转换 ， 将其转换为相同类型，然后在进行比较（转换不可控） NaN 不和任何值相等，包括本身 可以通过 isNaN() 函数来判断一个值是不是 NaN 如果该值是 NaN 返回 true ， 否则返回 false ； 2、 [ != ] 不相等 不相等用来判断两个值是否不相等 ，如果不相等返回 true ；否则返回 false ； 使用 [ != ] 来做 不相等运算 不相等也会对变量进行自动的类型转换，如果转换后相等也会返回 false ； 3、 [ === ] 全相等 用来判断两个值是否全等，它和相等类似 ；不同的是它不会自动转换数据类型 如果两个值类型不同，直接返回false ； 4、 [ !== ] 全不相等 用来判断两个值是否不全等，它和不相等类似 ；不同的是它不会自动转换数据类型 如果两个值类型不同，直接返回false ； 八、 条件 - 运算符（三元运算符）1、 语法条件表达式 ？ 语句 1 ：语句 2 ；2、 执行流程条件运算符在执行时 ， 首先对条件表达式进行求值， —如果该值为 true ，则执行语句 1 ；并返回执行结果 —如果该值为 false ，则执行语句 2 ；并返回执行结果 true？alert(“语句 1”)：alert(“语句 2”) var a = 10, b = 30, c=50; a &gt; b？alert(“语句 1”)：alert(“语句 2”) var max = a &gt; b ? a ：b ; console.log( max ); // 30 var max = max &gt; c ? max : c; console.log( max ); // 50 var max = a &gt; b ? (a &gt; c ? a : c) : (b &gt; c ? b:c) ; console.log( max ); // 50九、 运算符优先级 使用 [ , ] 可以分割多个语句 ， 一般可以在声明多个变量时使用 就和数学中一样 ， 在 JavaScript 中运算符也有优先级 在 JavaScript 中有个运算符优先级的表； 表中越靠上优先级越高，优先级越高越优先计算， 如果优先级一样，则从左往右依次计算。 ！！！这个表不需要记忆，如果遇到优先级拿不准的可以使用 （） 来改变优先级 ！！！！","path":"2019/09/14/JavaScript基础-2/","date":"09-14","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiao-long.club/tags/JavaScript/"}]},{"title":"JavaScript基础 - 数据类型及类型转换","text":"一、概述简单数据类型（值类型）： String Number Boolean 特殊数据类型 Null （type of 出来是 Object） Undefined 引用数据类型 Object Array Function 二、数据类型介绍2.1 String（字符串类型） 在 JavaScript 中字符串需要使用单引号/双引号 &quot;&quot; / &#39;&#39; 引起来使用（不可以讲单双引号混合使用） 引号内不能嵌套使用，如：双引号内继续使用双引号 在字符串内可以使用 \\ 反斜杠进行特殊字符转义 ES6 新增模板语法 反引号 在反引号内可以调用变量 123var name = 'Jerry'var str = `hello $&#123;name&#125;`console.log(str) -&gt; hello Jerry 2.2 Number (数值类型)JavaScript 中所有数值都是Number类型，包括整数和浮点（小数） * 可以使用 “语法 ： typeof 变量” 来检查数据类型 typeof只能检查基础数据类型 * 使用 typeof 来检查Infinity 和 NaN 返回的都是Number JS 中可以表示的最大值 Number.MAX_VSLUE * 如果使用的Number的数字超过最大值，输出 Infinity 表示正无穷大 JS 中可以表示的最小值 Number.MIN_VSLUEJS 中整数的运算基本可以保证精确JS 进行浮点数（小数）进行运算可能得到一个不精确的结果 1.3 Boolean（布尔）Boolean 布尔值只有两个 true - 表示“ 真 ” 。 计算机中存值为：1 false - 表示“ 假 ”。 计算机中存值为：0 1.4 Null（空值）Null 类型的值只有一个，就是 null null 专门用来表示一个为空的对象 用 typeof 检查 null 值时，会返回一个object （Bug） 1.5 Undefined（未定义）类型只有一个，就是undefined 当一个变量声明了，但并没有给这个变量赋值 ，它的值就是undefined 用 typeof 检查 undefined 时也会返回一个 undefined 二、类型转换强制类型转换 指讲一个数据类型强制转换为其他数据类型 类型转主要指 将其他数据类型转化为：String/Number/Boolean 2.1 将其他数据类型转化为 String（字符串） 转换方法一 ：调用被转换数据类型的 .toString() 方法 123456var a = 1,2,3; a = a.toString() console.log(typeof a) //打印出来的属性类型就是 string（字符串） * 该方法不会影响到原变量，它会将转换的结果返回 * ！注意 ！：null 和 undefined 这两个值都没有 .toString() 方法 转换方法二 ：调用 String（）函数，并将被转换的数据作为参数传递给函数 对于Number 和 Boolean 实际上就是调用的 .toString()的方法但是对于 null 和 undefined ，就不会调用 .toString()的方法，它会直接将null转换为“null”（字符串null） 123调用String（）函数来进行转化为字符串 var a = 123 String(a) ; 2.2 将其他数据类型转化为 Number（数字） 转换方法一 ：使用Number（）函数 – 字符串 —&gt; 数字 如果是纯数字的字符串，则直接将其转换为数字 如果字符串中有非数字的内容 ， 则会转换为 NaN 如果字符串是个空字符串或者全是空格的字符串，则转为“ 0 ” 纯数字字符串： 123456789101112131415 var a = \"456\" a = Number(a) console.log(typeof a) // 打印类型为 number ```js 含有非数字类型： ```js var a = \"456asd\" a = Number(a) console.log(typeof a) // 打印类型为 NaN ``` 含有非数字类型： ```js var a = \"456asd\" a = Number(a) console.log(typeof a) // 打印类型为 NaN – 布尔 —&gt; 数字 true 转成 ：1 ； false 转出 ： 0 ； – null —&gt; 数字 null 转成 ： 0 ； – undefined —&gt; 数字 1. undefined 转成 ： NaN ； 转换方法二 ：使用函数【parseInt（）—整形】和【parseFloat（）—浮点】 — 这种方式专门用来对付字符串 — parseInt() 把一个字符串转换为一个整数 — parseFloat（）把一个字符串转换为一个浮点数 调用parseInt()函数将 a 转化为Number parseInt()函数可以将一个字符串中有效的整数内容取出来 ,然后转换为Number。1234var a = \"120px\" a = parseInt( a ); console.log(typeof a) // 打印类型为 Number console.log( a ) // 120 调用parseFloat（）函数将 a 转化为Number parseFloat（）和parseInt()类似，不同的是他可以获取到有效的小数 1234var a = \"120.12512px\" a = parseInt( a ); console.log(typeof a) // 打印类型为 Number console.log( a ) // 120.12512 如果对非String使用parseInt（）和parseFloat（），会先将其转换为String ，再进行数据类型的转化 其他进制的数字 在 JS 中，如果需要表示 16 进制的数字，则需要以 0x 开头 ；输出的时候都会转化为十进制 如果需要表示八进制的数字 ， 则需要以 0 开头 ； 如果需要表示二进制的数字 ， 则需要以 ob 开头。（存在不兼容） 123456// 像“ 070 ”这样的字符串，有些浏览器会当做八进制进行解析，有些当做十进制解析 // 可以在parseInt（）中传递第二个参数，来指定数字的 进制类型var a = \"070\" ; a = parseInt( a ， 10); console.log(typeof a) // 打印类型为 Number console.log( a ) // 70 2.3 将其他数据类型转化为 Boolean（布尔） 转换方法一 ：使用Boolean（）函数 – 数字 —&gt; 布尔 除了 0 和 NaN ，其余的全是 true – 字符串 —&gt; 布尔 除了空字符串，其余都是 true – null 和 undefined —&gt; 布尔 null 和 undefined 转换为布尔全是 false – object —&gt; 布尔 Object（对象）转换为布尔全是 true 三、栈区与堆区 值类型存放在栈区 复杂数据类型存放在堆区，栈中存堆的地址","path":"2019/09/13/JavaScript基础-1/","date":"09-13","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiao-long.club/tags/JavaScript/"}]}]}